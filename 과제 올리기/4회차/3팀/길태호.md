# 6장. 퍼셉트론
--------------
인간의 뇌는 여러 뉴런으로 이루어져 있으며, 뉴런과 뉴런이 연결되어 자신의 역할을 수행한다.    
이처럼, 여러층의 퍼셉트론을 서로 연결시키고 복잡하게 조합하여 입력 값에 대한 판단을 하는 것이 신경망의 기본 구조이다.    
뉴런에서 전위가 임계 값을 넘겨야 다음 뉴런으로 신호를 전달하듯이,     
로지스틱회귀에서 활성화 함수의 일정 수준을 넘으면 참을, 그렇지 않으면 거짓을 내보낸다.    
![image](https://user-images.githubusercontent.com/94752167/215746216-98b0a53b-796d-49b9-9a7f-d21baa6c0a94.png)
     
신경망을 이루는 가장 중요한 기본 단위는 퍼셉트론이다.    
퍼셉트론은 입력값과 활성화 함수를 사용해 출력 값을 다음으로 넘기는 가장 작은 신경망의 단위이다.   

## 6.1 가중치, 가중합, 바이어스, 활성화함수
-------------
전에 표현했던 y=ax+b에서 a는 기울기를, b는 y절편을 의미했다. 이를 딥러닝에서는 y=wx+b로 표현할 수 있다.     
y=wx+b에서 w는 가중치를, b는 바이어스를 의미한다.    
이 y=wx+b는 가중합이라고 부른다.    
이 가중합의 결과를 놓고 1 또는 0을 판단하는 함수를 활성화함수라고 부른다.    

## 6.2 퍼셉트론의 과제
------------

사람의 뉴런과 마찬가지로 퍼셉트론은 여러개가 필요하다.    
![image](https://user-images.githubusercontent.com/94752167/215747867-b0818fcc-4a44-4f75-b6b8-1f912c3d27d6.png)        

위 그림에서 어떻게 선을 긋더라도 검은색과 흰색 점으로 분류할 수 없다.

## 6.3 XOR 문제
-----------
위와 같은 문제는 XOR 문제이다.    
XOR문제는 논리 회로에 등장하는 개념으로, x1과 x2가 하나는 1이고 하나는 0인 경우에 결과값이 1인 회로이다.     
![image](https://user-images.githubusercontent.com/94752167/215748464-b3886690-689a-465a-8ae3-cae039b5b5b6.png)     

AND 게이트와 OR 게이트와 달리, XOR 게이트에서는 선을 그어 검은 점을 구별할 수 없다.     
이러한 문제는 다층 퍼셉트론으로 해결하게 된다.    

# 7. 다층 퍼셉트론
-----------------

위에서 말한 XOR 문제를 해결하기 위해서는 종이를 휘어야 한다.   
즉, 좌표 평면 자체에 변화를 주어야 한다.    
![image](https://user-images.githubusercontent.com/94752167/215749336-b5fa082a-5f8c-48ce-8f53-40917b602e0c.png)    

따라서, xor 문제를 해결하기 위해서는 두 개의 퍼셉트론을 한번에 계산할 수 있어야 하며, 이를 위해 숨어있는 층인 은닉층을 만들어야 한다.  

![image](https://user-images.githubusercontent.com/94752167/215749560-72a9afc2-86cc-42c1-b618-4d84ff4e3fbd.png)    

은닉층은 좌표평면을 외곡시키는 결과를 가져온다.    

![image](https://user-images.githubusercontent.com/94752167/215749721-36365131-de6b-4ccd-85a1-892ac0efea66.png)    

위와 같이 입력값을 놓고 파란색과 빨간색을 구분할 때, 은닉층을 만들어 공간을 왜곡시키면, 두 영역을 가로지르는 선이 직선으로 바뀐다.    

## 7.1 다층 퍼셉트론 설계
-----------
다층 퍼셉트론이 입력층과 출력층 사이에 숨어있는 은닉층을 만드는 과정은 아래와 같다.     
![image](https://user-images.githubusercontent.com/94752167/215751002-cefc5c6e-e239-44e2-b474-5fbbf9327e25.png)     

은닉층으로 가중치 w와 바이어스 b 값을 보내고 은닉층에 모인 값이 시그모이드 함수를 통해 최종값으로 결과를 보낸다. 이후 시그모이드 함수를 이용해 최종값으로 결과를 보낸다. 은닉층에 모이는 중간 정거장을 노드라고 한다. 이 노드의 값은 각각 단일 퍼셉트론의 값과 같다.    
![image](https://user-images.githubusercontent.com/94752167/215752461-e7248275-9834-4e50-81fc-5136dfa1c4f8.png)     

이 식의 결과값이 출력층으로 보내지고, 이 두 결과값을 다시 가중치와 바이어스를 처리하고 시그모이드 함수를 거치는 과정을 가진다. 
![image](https://user-images.githubusercontent.com/94752167/215752632-ac01f68d-b37f-4382-a180-d75c0948b369.png)    

각각의 가중치와 바이어스의 값은 아래와 같다.   

![image](https://user-images.githubusercontent.com/94752167/215752928-390b564e-b0d3-4316-81f9-3e7726364fa4.png)     

## 7.2 XOR 문제의 해결
-------
위에서 말한 다층 퍼셉트론을 통해 xor 문제가 해결되는지 확인해보자.   

![image](https://user-images.githubusercontent.com/94752167/215753493-c0674be7-fbdf-439a-a4e3-cf76445b4293.png)    

각각의 가중치와 바이어스는 위와 같다.   

![image](https://user-images.githubusercontent.com/94752167/215753582-70438382-7714-44a0-9825-dc217f254900.png)    

도식은 위와 같다.    

![image](https://user-images.githubusercontent.com/94752167/215753711-f9624971-0543-4b7d-9816-242d9a93793e.png)    

그 결과값은 위와 같다. 은닉층을 통한 다층 퍼셉트론으로 XOR 문제를 해결한 것을 볼 수 있다.    


## 7.3 코딩으로  XOR 문제 해결하기
---------

위의 표를 보면 n1은 모드 1일 경우 0을, 이외의 경우에는 1을 출력하는 NAND 게이트이다.    
또한, n2는 OR 게이트이다.    
따라서, 두 게이트를 각각 작동시키고 두 값에 대해 AND 게이트를 수행한 값이 결과값 Y이다.   

![image](https://user-images.githubusercontent.com/94752167/215754629-67b9d9c7-8321-4d18-a5bf-ee7ce97efa4b.png)     
가중치와 바이어스는 위와 같다.   

![image](https://user-images.githubusercontent.com/94752167/215754772-a8f1ba8f-283a-465c-a98e-c433b4d185e5.png)    

퍼셉트론은 0과 1 중에서 값을 출력하게 설정한다.   
![image](https://user-images.githubusercontent.com/94752167/215754950-8fe33efe-adb1-4356-912b-31860dd1455d.png)    
![image](https://user-images.githubusercontent.com/94752167/215754986-654e4aee-efb6-4420-966a-c869ae98edc2.png)   

각 게이트의 정의에 따라 NAND,OR,AND,XOR 게이트를 만드면 위와 같다.   

![image](https://user-images.githubusercontent.com/94752167/215755154-ea21cd22-3498-4e01-961c-ab62f5ba8341.png)    

마지막으로 X1과 X2의 값을 대입해 가며 최종값을 출력하면 위와 같다.   

이를 모두 정리하면 아래와 같다.   

https://colab.research.google.com/drive/1Fvs7Rfig3MoFiIEXDZHd4efS_MKecxI5#scrollTo=L6v_OcXNxJvU

# 8장. 오차 역전파
----------

신경망 내부의 가중치는 오차 역전파 방법을 사용해 수정한다. 오차 역전파는 경사하강법의 확장 개념이다.    

## 8.1 오차 역전파의 개념
----------
가중치와 바이어스를 구하기 위해서는 오차 역전파를 사용한다. 오차 역전파는 최적화의 계산 방향이 출력층에서 시작해 앞으로 진행된다. 이러한 다층 퍼셉트론에서의 최적화 과정이 오차 역전파이다. ![image](https://user-images.githubusercontent.com/94752167/215764175-b788f2b7-9084-46a5-94be-a2808bc34a72.png)    

오차 역전파의 과정은 앞에서의 경사하강법과 비슷하다. 다만, 경사하강법은 입력과 출력이 하나인 단일 퍼셉트론일 경우에 사용했지만, 오차 역전파는 다층 퍼셉트론의 경우에 사용한다. 오차를 구해 이를 토해로 앞선 가중치를 차례로 거슬러 올라가며 조정해 간다. 이라헌 구동 방식은 아래와 같다.     

![image](https://user-images.githubusercontent.com/94752167/215764670-bb2f7a99-acca-42b6-b26a-c31ff74adb85.png)    

오차가 작아지는 방향으로 업데이트한다는 의미는 미분 값이 0에 가까워지는 방향으로 나아간다는 의미이다.   
다시 말하면, 가중치에서 기울기를 뺐을 때 변화가 없어야 한다.   
식으로 표현하면 아래와 같다.   
![image](https://user-images.githubusercontent.com/94752167/215764985-cca07263-24be-43bc-9137-34a1f8129927.png)    

## 8.2 코딩으로 확인하는 오차 역전파
-----------
오차 역전파의 경우 경사하강법과 달리 가중치를 몰라도 가능하다. 입력된 실제 값과 다층 퍼셉트론의 계산 결과를 비교하여 가중치를 역전파 방식으로 수정해나간다.    

![image](https://user-images.githubusercontent.com/94752167/215765358-fdc342d6-3692-4a53-b5a5-848d981e6aa8.png)    

![image](https://user-images.githubusercontent.com/94752167/215765523-6a7406b0-e9ba-4a09-9831-455da9eaf86b.png)    

# 9장. 신경망에서 딥러닝으로
------------




























